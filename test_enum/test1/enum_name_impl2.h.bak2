#pragma once
#include "arrow/typelist/static_array.h"
#include "arrow/typelist/static_string.h"
#include "arrow/typelist/type_name/type_name_impl.h"
#include <iostream>
#include <map>
#include <type_traits>

namespace Arrow2
{
using namespace Arrow;

namespace details
{


// 判断枚举是 class enum 还是 enum
template <typename EnumType, typename = typename std::enable_if<std::is_enum<EnumType >::value>::type>
struct IsScopedEnum : std::false_type
{
};

template <typename EnumType>
struct IsScopedEnum<EnumType , typename std::enable_if<!std::is_convertible<EnumType , int>::value>::type> : std::true_type
{
};

// 判断枚举值是否合法 ture 合法 false 不合法 [zhuyb 2023-08-13 17:13:55]
template <typename EnumType, EnumType val>
constexpr bool IsValid()
{
    return StaticStr::Find<1>(__PRETTY_FUNCTION__, "val = (") == std::string::npos;
}

// 枚举合法性定义 [zhuyb 2023-08-20 18:26:22]
template <typename EnumType, EnumType val, typename SFINEA = void>
struct Valid : public std::false_type
{
};

template <typename EnumType, EnumType val>
struct Valid<EnumType , val, typename std::enable_if<IsValid<EnumType , val>()>::type> : public std::true_type
{
};

// 获取枚举的字符串 [zhuyb 2023-08-21 15:46:23]
template <typename T, T val, typename EndTag=void>
struct EnumItemStrView
{
    static size_t TraceLength()
    {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return 0;
    }
    static constexpr size_t Length()
    {
        return StaticStr::Find<1>(__PRETTY_FUNCTION__, " EndTag = ") - 1 - StaticStr::Find<1>(__PRETTY_FUNCTION__, " val = ") - StaticStr::StrLen(" val = ");
    }

    static constexpr auto View() -> StaticStr::StringView<Length()>
    {   
        return StaticStr::StringView<Length()>(__PRETTY_FUNCTION__ + StaticStr::Find<1>(__PRETTY_FUNCTION__, " val = ") + StaticStr::StrLen(" val = "));
    }
    static constexpr decltype(EnumItemStrView<T, val, EndTag>::View()) value = EnumItemStrView<T, val, EndTag>::View();
    static constexpr size_t length = Length();
};
template <typename T, T val, typename EndTag>
constexpr decltype(EnumItemStrView<T, val, EndTag>::View()) EnumItemStrView<T, val, EndTag>::value;
template<typename T, T val, typename EndTag>
constexpr size_t EnumItemStrView<T, val, EndTag>::length;


// 结构体定义 [zhuyb 2023-08-21 15:42:48]
template <typename EnumType, EnumType val,
          typename Valid = typename Valid<EnumType, val>::type,
          typename ScopedEnum = typename IsScopedEnum<EnumType>::type>
struct EnumItemInfo
{
};

// 限定枚举类型 [zhuyb 2023-08-21 15:42:36]
template <typename EnumType, EnumType val>
struct EnumItemInfo<EnumType , val, std::true_type, std::true_type>
{
    using __EnumItemStrView = EnumItemStrView<EnumType, val>;

    constexpr static size_t Length()
    {
        return __EnumItemStrView::length - StaticStr::StrLen("::") - StaticStr::Find<1>(__EnumItemStrView::value, "::");
    }

    // 获取限定枚举的名称 [zhuyb 2023-08-13 17:31:28]
    static constexpr auto Str() -> StaticStr::StringView<Length()>
    {
        return StaticStr::SubStr<__EnumItemStrView::length - Length()>(__EnumItemStrView::value);
    }

    static constexpr decltype(EnumItemInfo<EnumType, val, std::true_type, std::true_type>::Str()) strView = 
                EnumItemInfo<EnumType, val, std::true_type, std::true_type>::Str();
    static constexpr const char* str =strView.data;
    static constexpr EnumType value=val;
};
template <typename EnumType, EnumType val>
constexpr decltype(EnumItemInfo<EnumType, val, std::true_type, std::true_type>::Str())
    EnumItemInfo<EnumType, val, std::true_type, std::true_type>::strView;
template <typename EnumType, EnumType val>
constexpr const char* EnumItemInfo<EnumType, val, std::true_type, std::true_type>::str;
template <typename EnumType, EnumType val>
constexpr EnumType EnumItemInfo<EnumType, val, std::true_type, std::true_type>::value;

// 非限定枚举类型 [zhuyb 2023-08-21 15:42:15]
template <typename EnumType, EnumType val>
struct EnumItemInfo<EnumType , val, std::true_type, std::false_type>
{
    using __EnumItemStrView = EnumItemStrView<EnumType, val>;

    static constexpr decltype(__EnumItemStrView::value) strView = __EnumItemStrView::value;
    static constexpr const char* str =strView.data;
    static constexpr EnumType value=val;
};
template <typename EnumType, EnumType val>
constexpr decltype(EnumItemStrView<EnumType, val>::value) EnumItemInfo<EnumType, val, std::true_type, std::false_type>::strView;
template <typename EnumType, EnumType val>
constexpr const char* EnumItemInfo<EnumType, val, std::true_type, std::false_type>::str;
template <typename EnumType, EnumType val>
constexpr EnumType EnumItemInfo<EnumType, val, std::true_type, std::false_type>::value;

// 不合法的枚举类型 [zhuyb 2023-08-21 15:43:01]
template <typename EnumType, EnumType val, typename ScopedEnum>
struct EnumItemInfo<EnumType , val, std::false_type, ScopedEnum>
{
    using valueType = typename std::underlying_type<EnumType >::type;
    static constexpr auto Str() -> decltype(Arrow::TypeName<EnumType >::Impl() + StaticStr::Str(" undefined:") + StaticStr::NumToStr<valueType, static_cast<valueType>(val)>())
    {
        return Arrow::TypeName<EnumType >::Impl() + StaticStr::Str(" undefined:") + StaticStr::NumToStr<valueType, static_cast<valueType>(val)>();
    }

    static constexpr decltype(EnumItemInfo<EnumType, val, std::false_type, ScopedEnum>::Str()) strView = EnumItemInfo<EnumType, val, std::false_type, ScopedEnum>::Str();
    static constexpr const char* str = strView.data;
    static constexpr EnumType value = val;
};
template <typename EnumType, EnumType val, typename ScopedEnum>
constexpr decltype(EnumItemInfo<EnumType, val, std::false_type, ScopedEnum>::Str())
    EnumItemInfo<EnumType, val, std::false_type, ScopedEnum>::strView;
    template <typename EnumType, EnumType val, typename ScopedEnum>
constexpr const char* EnumItemInfo<EnumType, val, std::false_type, ScopedEnum>::str;
template <typename EnumType, EnumType val, typename ScopedEnum>
constexpr EnumType EnumItemInfo<EnumType, val, std::false_type, ScopedEnum>::value;
}

// template<typename EnumType>
// struct EnumItemInfo
// {
//     constexpr EnumItemInfo() : value(0), name(nullptr){}
//     constexpr EnumItemInfo(EnumType v, const char* data) : value(v), name(data) {}

//     EnumType value;
//     const char* name;
// };


#define IS_VALID(T, startIndex, i, j) Arrow2::details::IsValid<EnumType , static_cast<EnumType >(startIndex + 0x##i##j)>()

#define ENUM_ITEM_NAME(T, startIndex, i, j) Arrow2::details::EnumItemStrView<EnumType , static_cast<EnumType >(startIndex + 0x##i##j)>::value.data

#define ENUM_ITEM_INFO(T, startIndex, i, j) Arrow2::EnumItemInfo<EnumType >(static_cast<EnumType >(startIndex + 0x##i##j), ENUM_ITEM_NAME(T, startIndex, i, j))

#define ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, j) F(T, startIndex, i,j)

#define ARROW_ENUM_FOR_EACH_I(F, T, startIndex, i) ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 0), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 1), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 2), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 3), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 4), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 5), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 6), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 7), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 8), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, 9), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, a), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, b), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, c), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, d), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, e), \
                                                   ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, i, f)

#define ARROW_ENUM_FOR_EACH_2(F, T, startIndex) ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, 0, 0), \
                                                ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, 0, 1)

#define ARROW_ENUM_FOR_EACH_4(F, T, startIndex) ARROW_ENUM_FOR_EACH_2(F, T, startIndex),         \
                                                ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, 0, 2), \
                                                ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, 0, 3)

#define ARROW_ENUM_FOR_EACH_8(F, T, startIndex) ARROW_ENUM_FOR_EACH_4(F, T, startIndex),         \
                                                ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, 0, 4), \
                                                ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, 0, 5), \
                                                ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, 0, 6), \
                                                ARROW_ENUM_FOR_EACH_I_J(F, T, startIndex, 0, 7)

#define ARROW_ENUM_FOR_EACH_16(F, T, startIndex) ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 0)

#define ARROW_ENUM_FOR_EACH_32(F, T, startIndex) ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 0), \
                                                 ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 1)

#define ARROW_ENUM_FOR_EACH_64(F, T, startIndex) ARROW_ENUM_FOR_EACH_32(F, T, startIndex),   \
                                                 ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 2), \
                                                 ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 3)

#define ARROW_ENUM_FOR_EACH_128(F, T, startIndex) ARROW_ENUM_FOR_EACH_64(F, T, startIndex),   \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 4), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 5), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 6), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 7)

#define ARROW_ENUM_FOR_EACH_256(F, T, startIndex) ARROW_ENUM_FOR_EACH_128(F, T, startIndex),  \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 8), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, 9), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, a), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, b), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, c), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, d), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, e), \
                                                  ARROW_ENUM_FOR_EACH_I(F, T, startIndex, f)

#define ARROW_ENUM_FOR_EACH_Impl(F, T, startIndex, StepSize) ARROW_ENUM_FOR_EACH_##StepSize(F, T, startIndex)
#define ARROW_ENUM_FOR_EACH(F, T, startIndex, StepSize) ARROW_ENUM_FOR_EACH_Impl(F, T, startIndex, StepSize)

// // clang最大只支持128个参数初始化 gcc最大支持256个参数
// #define ENUM_STEP_SIZE_16 16
// #define ENUM_STEP_SIZE_32 32
// #define ENUM_STEP_SIZE_64 64
// #define ENUM_STEP_SIZE_128 128
// using IntegerSequenceEnumStepSize16 = Arrow::MakeIntegerSequence<ENUM_STEP_SIZE_16>::type;
// using IntegerSequenceEnumStepSize32 = Arrow::MakeIntegerSequence<ENUM_STEP_SIZE_32>::type;
// using IntegerSequenceEnumStepSize64 = Arrow::MakeIntegerSequence<ENUM_STEP_SIZE_64>::type;
// using IntegerSequenceEnumStepSize128 = Arrow::MakeIntegerSequence<ENUM_STEP_SIZE_128>::type;


// // 常规执行 [zhuyb 2023-08-19 22:34:31]
// template <typename EnumType, typename std::underlying_type<EnumType >::type enumStart, typename std::underlying_type<EnumType >::type enumEnd, typename SFINEA = void>
// struct EnumItemArrayInterval
// {
//     using __EnumItemInfo = EnumItemInfo<EnumType >;
//     using __EnumItemStrView = details::EnumItemStrView<EnumType , static_cast<EnumType >(enumStart)>;
//     static constexpr Array::ArrayView<__EnumItemInfo, static_cast<size_t>(enumEnd - enumStart + 1)> Array()
//     {
//         return Array::ArrayView<__EnumItemInfo, 1>(__EnumItemInfo(static_cast<EnumType >(enumStart), __EnumItemStrView::value.data)) + 
//                 EnumItemArrayInterval<EnumType , enumStart + 1, enumEnd>::Array();
//     }
// };

// // 递归结束 [zhuyb 2023-08-19 22:34:31]
// template <typename EnumType, typename std::underlying_type<EnumType >::type enumStart, typename std::underlying_type<EnumType >::type enumEnd>
// struct EnumItemArrayInterval<EnumType , enumStart, enumEnd, typename std::enable_if<(enumStart == enumEnd)>::type>
// {
//     using __EnumItemInfo = EnumItemInfo<EnumType >;
//     using __EnumItemStrView = details::EnumItemStrView<EnumType , static_cast<EnumType >(enumStart)>;
//     static constexpr Array::ArrayView<__EnumItemInfo, 1> Array()
//     {
//         return Array::ArrayView<__EnumItemInfo, 1>(__EnumItemInfo(static_cast<EnumType >(enumStart), __EnumItemStrView::value.data));
//     }
// };

// // 用于提高编译效率。 多倍率执行 [zhuyb 2023-08-19 22:35:25]
// #define ENUM_ITEM_LIST_StepSize(StepSize)                                                                                                                                                               \
//     template <typename EnumType, typename std::underlying_type<EnumType>::type enumStart, typename std::underlying_type<EnumType>::type enumEnd>                                                        \
//     struct EnumItemArrayInterval<EnumType, enumStart, enumEnd, typename std::enable_if<(enumEnd >= StepSize + enumStart - 1 && enumEnd < StepSize * 2 + enumStart - 1)>::type>                          \
//     {                                                                                                                                                                                                   \
//         using __EnumItemInfo = EnumItemInfo<EnumType>;                                                                                                                                                  \
//         static constexpr Array::ArrayView<__EnumItemInfo, static_cast<size_t>(enumEnd - enumStart + 1)> Array()                                                                                         \
//         {                                                                                                                                                                                               \
//             return Array::ArrayView<__EnumItemInfo, StepSize>({ARROW_ENUM_FOR_EACH(ENUM_ITEM_INFO, T, enumStart, StepSize)}) + EnumItemArrayInterval<EnumType, enumStart + StepSize, enumEnd>::Array(); \
//         }                                                                                                                                                                                               \
//     };

// //定义16倍执行力
// ENUM_ITEM_LIST_StepSize(4)
// ENUM_ITEM_LIST_StepSize(8)
// ENUM_ITEM_LIST_StepSize(16)
// ENUM_ITEM_LIST_StepSize(32)
// ENUM_ITEM_LIST_StepSize(64)
// ENUM_ITEM_LIST_StepSize(128)

// template <typename EnumType, EnumType... enumArgs>
// struct EnumItemArray{};

// template <typename EnumType, EnumType enumStart1, EnumType enumEnd1, EnumType enumStart2, EnumType... enumArgs>
// struct EnumItemArray<EnumType, enumStart1, enumEnd1, enumStart2, enumArgs...>
// {

//     static_assert(sizeof...(enumArgs) % 2 == 1 , "枚举参数的个数必须为偶数个，首尾成对出现");
//     static_assert(enumEnd1 >= enumStart1 ,"枚举值必须连续,且为递增序列");
//     static_assert(enumEnd1 <= enumStart2 ,"枚举值必须连续,且为递增序列");
//     // using type = details::EnumListToStrImpl<EnumType, enumArgs...>;
//     // using value = details::EnumListData<EnumType>;

//     // // static bool gInit;
//     // static const char* ItemStr(EnumType enumValue)
//     // {
//     //     // static bool bInit = type::Init();
//     //     auto it = value::value.find(enumValue);
//     //     if(it == value::value.end())
//     //     {
//     //         return "";
//     //     }
//     //     return it->second;
//     // }
// };

}